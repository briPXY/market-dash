// secretManager.js
import fs from "fs/promises";
import fsSync from "fs";
import path from "path";
import crypto from "crypto";

const _ALGO = "aes-256-gcm";

const allowedKeyNames = { subgraph_api_key: true };

// Master key is generated by each user's signature, make it not exposed to dev(s)
function _deriveMasterKey(walletAddress, signature) {
    const salt = crypto.createHash("sha256").update(walletAddress).digest();
    return crypto.pbkdf2Sync(signature, salt, 100000, 32, "sha256");
}

const userDataFIleName = (input) => {
    const safeFileName = crypto.createHash("sha256").update(input).digest("hex");
    return path.join(process.cwd(), "server", "user", `data_${safeFileName}.json`);
}

function _encryptString(input, MASTER_KEY) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(_ALGO, MASTER_KEY, iv);

    const encrypted = Buffer.concat([
        cipher.update(input, "utf8"),
        cipher.final()
    ]);

    const tag = cipher.getAuthTag();

    return {
        ciphertext: encrypted.toString("base64"),
        iv: iv.toString("base64"),
        tag: tag.toString("base64")
    };
}

function _decryptString({ ciphertext, iv, tag }, MASTER_KEY) {
    const decipher = crypto.createDecipheriv(
        _ALGO,
        MASTER_KEY,
        Buffer.from(iv, "base64")
    );
    decipher.setAuthTag(Buffer.from(tag, "base64"));

    const decrypted = Buffer.concat([
        decipher.update(Buffer.from(ciphertext, "base64")),
        decipher.final()
    ]);

    return decrypted.toString("utf8");
}
async function _loadData(walletAddress) {
    const fileName = userDataFIleName(walletAddress);
    try {
        await fs.access(fileName);
    } catch {
        // create file with restricted permissions
        const initial = {};
        const tmp = fileName + ".tmp";
        await fs.writeFile(tmp, JSON.stringify(initial, null, 2), { mode: 0o600 });
        await fs.rename(tmp, fileName);
        return initial;
    }

    const raw = await fs.readFile(fileName, "utf8");
    try {
        return JSON.parse(raw || "{}");
    } catch (err) {
        throw new Error("user data file corrupted" + err);
    }
}

async function _saveData(walletAddress, data) {
    const fileName = userDataFIleName(walletAddress);
    const tmp = fileName + ".tmp";
    await fs.writeFile(tmp, JSON.stringify(data, null, 2), { mode: 0o600 });
    await fs.rename(tmp, fileName);
}


// Save encrypted data for a given wallet/user. 
export async function setUserSecret(keyName, walletAddress, apiKey, signature) {
    if (!allowedKeyNames[keyName]) throw new Error("object key name not allowed");
    const masterKey = _deriveMasterKey(walletAddress, signature);
    const encryptedString = _encryptString(apiKey, masterKey);
    const data = await _loadData(walletAddress);

    data.wallet_address = walletAddress;
    data[keyName] = encryptedString;
    data.created_at = new Date().toISOString();
    data.last_used_at = new Date().toISOString();

    await _saveData(walletAddress, data);
}

export async function getUserSecret(keyName, walletAddress, signature) {
    if (!fsSync.existsSync(userDataFIleName(walletAddress))) throw new Error("user data with this wallet address not found");

    const data = await _loadData(walletAddress);
    const masterKey = _deriveMasterKey(walletAddress, signature);

    if (!data[keyName]) throw new Error("key name is missing");

    const decrypted = _decryptString(data[keyName], masterKey)
    data.last_used_at = new Date().toISOString();
    await _saveData(walletAddress, data);
    return decrypted;
}

export async function deleteUserSecret(walletAddress) {
    const fileName = userDataFIleName(walletAddress);
    try {
        if (!fsSync.existsSync(fileName)) throw new Error("User data already deleted/not existed");
        await fs.unlink(fileName);
        return true;
    } catch {
        return false;
    }
}